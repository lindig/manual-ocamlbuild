<!doctype html public "-//W3C//DTD HTML 4.0 Transitional //EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset-us-ascii">
  <style>

@font-face {
  font-family: octicons-anchor;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAYcAA0AAAAACjQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAABMAAAABwAAAAca8vGTk9TLzIAAAFMAAAARAAAAFZG1VHVY21hcAAAAZAAAAA+AAABQgAP9AdjdnQgAAAB0AAAAAQAAAAEACICiGdhc3AAAAHUAAAACAAAAAj//wADZ2x5ZgAAAdwAAADRAAABEKyikaNoZWFkAAACsAAAAC0AAAA2AtXoA2hoZWEAAALgAAAAHAAAACQHngNFaG10eAAAAvwAAAAQAAAAEAwAACJsb2NhAAADDAAAAAoAAAAKALIAVG1heHAAAAMYAAAAHwAAACABEAB2bmFtZQAAAzgAAALBAAAFu3I9x/Nwb3N0AAAF/AAAAB0AAAAvaoFvbwAAAAEAAAAAzBdyYwAAAADP2IQvAAAAAM/bz7t4nGNgZGFgnMDAysDB1Ml0hoGBoR9CM75mMGLkYGBgYmBlZsAKAtJcUxgcPsR8iGF2+O/AEMPsznAYKMwIkgMA5REMOXicY2BgYGaAYBkGRgYQsAHyGMF8FgYFIM0ChED+h5j//yEk/3KoSgZGNgYYk4GRCUgwMaACRoZhDwCs7QgGAAAAIgKIAAAAAf//AAJ4nHWMMQrCQBBF/0zWrCCIKUQsTDCL2EXMohYGSSmorScInsRGL2DOYJe0Ntp7BK+gJ1BxF1stZvjz/v8DRghQzEc4kIgKwiAppcA9LtzKLSkdNhKFY3HF4lK69ExKslx7Xa+vPRVS43G98vG1DnkDMIBUgFN0MDXflU8tbaZOUkXUH0+U27RoRpOIyCKjbMCVejwypzJJG4jIwb43rfl6wbwanocrJm9XFYfskuVC5K/TPyczNU7b84CXcbxks1Un6H6tLH9vf2LRnn8Ax7A5WQAAAHicY2BkYGAA4teL1+yI57f5ysDNwgAC529f0kOmWRiYVgEpDgYmEA8AUzEKsQAAAHicY2BkYGB2+O/AEMPCAAJAkpEBFbAAADgKAe0EAAAiAAAAAAQAAAAEAAAAAAAAKgAqACoAiAAAeJxjYGRgYGBhsGFgYgABEMkFhAwM/xn0QAIAD6YBhwB4nI1Ty07cMBS9QwKlQapQW3VXySvEqDCZGbGaHULiIQ1FKgjWMxknMfLEke2A+IJu+wntrt/QbVf9gG75jK577Lg8K1qQPCfnnnt8fX1NRC/pmjrk/zprC+8D7tBy9DHgBXoWfQ44Av8t4Bj4Z8CLtBL9CniJluPXASf0Lm4CXqFX8Q84dOLnMB17N4c7tBo1AS/Qi+hTwBH4rwHHwN8DXqQ30XXAS7QaLwSc0Gn8NuAVWou/gFmnjLrEaEh9GmDdDGgL3B4JsrRPDU2hTOiMSuJUIdKQQayiAth69r6akSSFqIJuA19TrzCIaY8sIoxyrNIrL//pw7A2iMygkX5vDj+G+kuoLdX4GlGK/8Lnlz6/h9MpmoO9rafrz7ILXEHHaAx95s9lsI7AHNMBWEZHULnfAXwG9/ZqdzLI08iuwRloXE8kfhXYAvE23+23DU3t626rbs8/8adv+9DWknsHp3E17oCf+Z48rvEQNZ78paYM38qfk3v/u3l3u3GXN2Dmvmvpf1Srwk3pB/VSsp512bA/GG5i2WJ7wu430yQ5K3nFGiOqgtmSB5pJVSizwaacmUZzZhXLlZTq8qGGFY2YcSkqbth6aW1tRmlaCFs2016m5qn36SbJrqosG4uMV4aP2PHBmB3tjtmgN2izkGQyLWprekbIntJFing32a5rKWCN/SdSoga45EJykyQ7asZvHQ8PTm6cslIpwyeyjbVltNikc2HTR7YKh9LBl9DADC0U/jLcBZDKrMhUBfQBvXRzLtFtjU9eNHKin0x5InTqb8lNpfKv1s1xHzTXRqgKzek/mb7nB8RZTCDhGEX3kK/8Q75AmUM/eLkfA+0Hi908Kx4eNsMgudg5GLdRD7a84npi+YxNr5i5KIbW5izXas7cHXIMAau1OueZhfj+cOcP3P8MNIWLyYOBuxL6DRylJ4cAAAB4nGNgYoAALjDJyIAOWMCiTIxMLDmZedkABtIBygAAAA==) format('woff');
}

body {
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
  color: #333;
  /* overflow: hidden; */
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
  min-width: 200px;
  max-width: 790px;
  margin: 0 auto;
  padding: 30px;
}

 a {
  background-color: transparent;
}

 a:active,
 a:hover {
  outline: 0;
}

 strong {
  font-weight: bold;
}

 h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

 img {
  border: 0;
}

 hr {
  box-sizing: content-box;
  height: 0;
}

 pre {
  overflow: auto;
}

 code,
 kbd,
 pre {
  font-family: monospace, monospace;
  font-size: 1em;
}

 input {
  color: inherit;
  font: inherit;
  margin: 0;
}

 html input[disabled] {
  cursor: default;
}

 input {
  line-height: normal;
}

 input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

 table {
  border-collapse: collapse;
  border-spacing: 0;
}

 td,
 th {
  padding: 0;
}

 * {
  box-sizing: border-box;
}

 input {
  font: 13px/1.4 Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
}

 a {
  color: #4078c0;
  text-decoration: none;
}

 a:hover,
 a:active {
  text-decoration: underline;
}

 hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

 hr:before {
  display: table;
  content: "";
}

 hr:after {
  display: table;
  clear: both;
  content: "";
}

 h1,
 h2,
 h3,
 h4,
 h5,
 h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

 h1 {
  font-size: 30px;
}

 h2 {
  font-size: 21px;
}

 h3 {
  font-size: 16px;
}

 h4 {
  font-size: 14px;
}

 h5 {
  font-size: 12px;
}

 h6 {
  font-size: 11px;
}

 blockquote {
  margin: 0;
}

 ul,
 ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

 ol ol,
 ul ol {
  list-style-type: lower-roman;
}

 ul ul ol,
 ul ol ol,
 ol ul ol,
 ol ol ol {
  list-style-type: lower-alpha;
}

 dd {
  margin-left: 0;
}

 code {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

 pre {
  margin-top: 0;
  margin-bottom: 0;
  font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

 .select::-ms-expand {
  opacity: 0;
}

 .octicon {
  font: normal normal normal 16px/1 octicons-anchor;
  display: inline-block;
  text-decoration: none;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

 .octicon-link:before {
  content: '\f05c';
}

>*:first-child {
  margin-top: 0 !important;
}

>*:last-child {
  margin-bottom: 0 !important;
}

 a:not([href]) {
  color: inherit;
  text-decoration: none;
}

 .anchor {
  position: absolute;
  top: 0;
  left: 0;
  display: block;
  padding-right: 6px;
  padding-left: 30px;
  margin-left: -30px;
}

 .anchor:focus {
  outline: none;
}

 h1,
 h2,
 h3,
 h4,
 h5,
 h6 {
  position: relative;
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

 h1 .octicon-link,
 h2 .octicon-link,
 h3 .octicon-link,
 h4 .octicon-link,
 h5 .octicon-link,
 h6 .octicon-link {
  display: none;
  color: #000;
  vertical-align: middle;
}

 h1:hover .anchor,
 h2:hover .anchor,
 h3:hover .anchor,
 h4:hover .anchor,
 h5:hover .anchor,
 h6:hover .anchor {
  padding-left: 8px;
  margin-left: -30px;
  text-decoration: none;
}

 h1:hover .anchor .octicon-link,
 h2:hover .anchor .octicon-link,
 h3:hover .anchor .octicon-link,
 h4:hover .anchor .octicon-link,
 h5:hover .anchor .octicon-link,
 h6:hover .anchor .octicon-link {
  display: inline-block;
}

 h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

 h1 .anchor {
  line-height: 1;
}

 h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

 h2 .anchor {
  line-height: 1;
}

 h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

 h3 .anchor {
  line-height: 1.2;
}

 h4 {
  font-size: 1.25em;
}

 h4 .anchor {
  line-height: 1.2;
}

 h5 {
  font-size: 1em;
}

 h5 .anchor {
  line-height: 1.1;
}

 h6 {
  font-size: 1em;
  color: #777;
}

 h6 .anchor {
  line-height: 1.1;
}

 p,
 blockquote,
 ul,
 ol,
 dl,
 table,
 pre {
  margin-top: 0;
  margin-bottom: 16px;
}

 hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

 ul,
 ol {
  padding-left: 2em;
}

 ul ul,
 ul ol,
 ol ol,
 ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

 li>p {
  margin-top: 16px;
}

 dl {
  padding: 0;
}

 dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

 dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

 blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

 blockquote>:first-child {
  margin-top: 0;
}

 blockquote>:last-child {
  margin-bottom: 0;
}

 table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

 table th {
  font-weight: bold;
}

 table th,
 table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

 table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

 table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

 img {
  max-width: 100%;
  box-sizing: border-box;
}

 code {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

 code:before,
 code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

 pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

 .highlight {
  margin-bottom: 16px;
}

 .highlight pre,
 pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

 .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

 pre {
  word-wrap: normal;
}

 pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

 pre code:before,
 pre code:after {
  content: normal;
}

 kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

 .pl-c {
  color: #969896;
}

 .pl-c1,
 .pl-s .pl-v {
  color: #0086b3;
}

 .pl-e,
 .pl-en {
  color: #795da3;
}

 .pl-s .pl-s1,
 .pl-smi {
  color: #333;
}

 .pl-ent {
  color: #63a35c;
}

 .pl-k {
  color: #a71d5d;
}

 .pl-pds,
 .pl-s,
 .pl-s .pl-pse .pl-s1,
 .pl-sr,
 .pl-sr .pl-cce,
 .pl-sr .pl-sra,
 .pl-sr .pl-sre {
  color: #183691;
}

 .pl-v {
  color: #ed6a43;
}

 .pl-id {
  color: #b52a1d;
}

 .pl-ii {
  background-color: #b52a1d;
  color: #f8f8f8;
}

 .pl-sr .pl-cce {
  color: #63a35c;
  font-weight: bold;
}

 .pl-ml {
  color: #693a17;
}

 .pl-mh,
 .pl-mh .pl-en,
 .pl-ms {
  color: #1d3e81;
  font-weight: bold;
}

 .pl-mq {
  color: #008080;
}

 .pl-mi {
  color: #333;
  font-style: italic;
}

 .pl-mb {
  color: #333;
  font-weight: bold;
}

 .pl-md {
  background-color: #ffecec;
  color: #bd2c00;
}

 .pl-mi1 {
  background-color: #eaffea;
  color: #55a532;
}

 .pl-mdr {
  color: #795da3;
  font-weight: bold;
}

 .pl-mo {
  color: #1d3e81;
}

 kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

 .task-list-item {
  list-style-type: none;
}

 .task-list-item+.task-list-item {
  margin-top: 3px;
}

 .task-list-item input {
  margin: 0 0.35em 0.25em -1.6em;
  vertical-align: middle;
}

 :checked+.radio-label {
  z-index: 1;
  position: relative;
  border-color: #4078c0;
}
  </style>
</head>
<body>
    <a name="Table.of.contents"></a>
<h1>Table of contents</h1>

<ul>
<li><a href="#intro">A short introduction to OCamlbuild</a>

<ul>
<li><a href="#intro-purpose">What is OCamlbuild for?</a></li>
<li><a href="#intro-examples">Examples</a></li>
<li><a href="#intro-pros-cons-alternatives">Pros, Cons, and Alternatives</a></li>
<li><a href="#intro-core-concepts">Core concepts</a>

<ul>
<li><a href="#concept-rules-targets">Rules and targets</a></li>
<li><a href="#concept-tags">Tags and the <code>_tags</code> file</a></li>
<li><a href="#concept-myocamlbuild"><code>myocamlbuild.ml</code></a></li>
</ul>
</li>
<li><a href="#intro-example">A simple program</a></li>
<li><a href="#intro-hygiene">Hygiene</a></li>
<li><a href="#intro-ocamlfind">OCamlfind packages</a></li>
<li><a href="#intro-preproc">Syntax extensions</a></li>
<li><a href="#intro-archive-doc">Archives, documentation&hellip;</a></li>
<li><a href="#intro-paths">Source and build directories, module paths, include paths</a>

<ul>
<li><a href="#paths-module-include">Module paths and include directories</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#reference">Reference documentation</a>

<ul>
<li><a href="#reference-compiler-extensions">File extensions of the OCaml compiler and common tools</a></li>
<li><a href="#reference-targets">Targets and rules</a>

<ul>
<li><a href="#targets-basics">Basic targets</a></li>
<li><a href="#targets-ocamldoc">ocamldoc targets</a></li>
<li><a href="#targets-parsegen">OCamlYacc and Menhir targets</a></li>
<li><a href="#targets-deprecated">Deprecated targets</a></li>
</ul>
</li>
<li><a href="#reference-tags">Tags</a>

<ul>
<li><a href="#tags-basics">Basic tags</a></li>
<li><a href="#tags-advanced">Advanced (context) tags</a></li>
</ul>
</li>
<li><a href="#reference-documentation">The <code>-documentation</code> option</a></li>
<li><a href="#reference-tags-file">Syntax of <code>_tags</code> file</a></li>
</ul>
</li>
<li><a href="#plugins">Enriching OCamlbuild through plugins</a>

<ul>
<li><a href="#plugins-myocamlbuild-file">How <code>myocamlbuild.ml</code> works</a></li>
<li><a href="#plugins-dispatch">Dispatch</a></li>
<li><a href="#plugins-new-flags">Flag declarations</a>

<ul>
<li><a href="#flags-parametrized">Parametrized tags</a></li>
</ul>
</li>
<li><a href="#plugins-new-rules">Rule declarations</a>

<ul>
<li><a href="#rules-dynamic-deps">Dynamic dependencies</a></li>
<li><a href="#rules-stamps">Stamps</a></li>
<li><a href="#rules-patterns">Pattern variables</a></li>
</ul>
</li>
<li><a href="#plugins-example">Complete example: menhir support in OCamlbuild</a></li>
</ul>
</li>
<li><a href="#contributing">Contributing to OCamlbuild</a></li>
</ul>


<a name="A.short.introduction.to.OCamlbuild..a.id..intro....a."></a>
<h1>A short introduction to OCamlbuild <a id="intro"></a></h1>

<a name="What.is.OCamlbuild.for...a.id..intro-purpose....a."></a>
<h2>What is OCamlbuild for? <a id="intro-purpose"></a></h2>

<p>OCamlbuild&rsquo;s job is to determine the sequence of calls to the
compiler, with the right set of command-line flags, needed to build
your OCaml project.</p>

<p>OCamlbuild is extremely convenient to use for simple projects. If you
have a small OCaml project (program or library), chances are you can
directly invoke ocamlbuild to automatically discover various
source files and dependencies, and build executables, library archives
or documentation with one-line commands. In simple cases you don&rsquo;t
need to write a configuration file at all.</p>

<p>A few examples of quick ocamlbuild commands:</p>

<pre><code>ocamlbuild foo.byte
# builds a bytecode executable out of foo.ml and its local dependencies

ocamlbuild foo.native
# builds a native executable

ocamlbuild lib.cma
# builds a library archive from the modules listed (capitalized) in lib.mllib

ocamlbuild lib.docdir/index.html
# builds OCamldoc documentation from the modules listed in lib.odocl

ocamlbuild -use-ocamlfind -pkgs lwt,react,yojson,sedlex.ppx -tag debug foo.native
# enable a few ocamlfind packages and compile in debug mode
</code></pre>

<p>If repeating <code>-pkgs lwt,react,yojson,sedlex.ppx -tag debug</code> becomes bothersome,
you can create a <code>_tags</code> file in the project directory with the content:</p>

<pre><code>true: package(lwt), package(react), package(sedlex), package(yojson), debug
</code></pre>

<p>and then just use</p>

<pre><code> ocamlbuild -use-ocamlfind foo.native
</code></pre>

<p>OCamlbuild was designed as a generic build system (it is in fact not
OCaml-specific), but also to be expressive enough to cover the
specifics of the OCaml language that make writing good Makefiles
difficult, such as the dreaded &ldquo;units Foo and Bar make inconsistent
assumptions about Baz&rdquo; error.</p>

<a name="Examples..a.id..intro-examples....a."></a>
<h2>Examples <a id="intro-examples"></a></h2>

<p>We have included self-contained examples of projects using various
OCamlbuild features in the <a href="examples/">examples/</a> sub-directory of
this documentation, which may serve as inspiration.</p>

<p>Note that there are many ways to integrate ocamlbuild in your project;
the examples provided so far use a Makefile on top of ocamlbuild to
provide the familiar <code>make; make install; make clean</code> interface to
users, but you should of course feel free to do otherwise.</p>

<p>The examples available are the following:</p>

<ul>
<li><p><a href="examples/01-simple">simple</a>: a minimal example with self-contained
OCaml code in the project directory</p></li>
<li><p><a href="examples/02-subdirs">subdirs</a>: OCaml code in <code>lib/</code> and <code>src/</code>
subdirectories. See our <a href="#intro-paths">Source and build directories, module paths,
include paths</a> introduction section for more details.</p></li>
<li><p><a href="examples/03-packages">packages</a>: a simple example of use of an
OCamlfind package (<a href="http://mjambon.com/yojson.html">yojson</a>) in an
OCamlbuild project. See our <a href="#intro-ocamlfind">OCamlfind packages</a>
introduction section for more details.</p></li>
<li><p><a href="examples/04-library">library</a>: a simple example of using a <code>.mllib</code>
file to easily build library archives (<code>.cma</code> in bytecode, <code>.cmxa</code>
with native compilation). See our <a href="#intro-archive-doc">Archives,
documentation&hellip;</a> introduction section for more
details.</p></li>
<li><p><a href="examples/05-lex-yacc">lex-yacc</a>: a simple program using OCamllex to
generate a lexer, and
<a href="http://gallium.inria.fr/~fpottier/menhir/">Menhir</a> to generate
a parser (ocamlyacc would work as easily, but we recommend using
Menhir instead which is just a better parser generator). See our
<a href="#targets-parsegen">OCamlYacc and Menhir targets</a> reference section
for all parser-relevant options.</p></li>
</ul>


<a name="Pros..Cons..and.Alternatives..a.id..intro-pros-cons-alternatives....a."></a>
<h2>Pros, Cons, and Alternatives <a id="intro-pros-cons-alternatives"></a></h2>

<p>The main strengths of OCamlbuild are the following:</p>

<ul>
<li><p>It &ldquo;Just Works&rdquo; for most OCaml projects, with minimal configuration
work on your part.</p></li>
<li><p>It is designed from the scratch with dynamic dependencies in
mind. Dynamic dependencies are the dependencies that are only
determined during the build of the target, eg. the local modules on
which a source file depends, and are not explicitly listed in
a configuration file. This avoids, for example, the dance of
pre-generating or post-generating <code>.depends</code> files that is
occasionally bothersome with Makefile projects, without requiring
you to describe all local dependency relations manually either.</p></li>
</ul>


<p>Two weaknesses are the following:</p>

<ul>
<li><p>Instead of a home-grown soon-to-become-turing-complete configuration
language, OCamlbuild made the choice of using OCaml as its
configuration language, and many users dislike this choice. Most
features of OCamlbuild can be controlled through the purely
declarative <code>_tags</code> file whose structure is explained in detail in
this documentation, but for more complex projects you will
eventually need to create a <code>myocamlbuild.ml</code> to configure the tool
through its OCaml library interface. We strive for a simple API and
we document it, so that should be more pleasant than you expect.</p></li>
<li><p>OCamlbuild is not the most efficient build system out there, and in
particular its support for build parallelization is currently
disappointing. This could be solved with more engineering efforts;
OCamlbuild is maintained by volunteers, and your contributions are
warmly welcome, see the <a href="#contributing">Contributing</a> section of
this document. For now, OCamlbuild&rsquo;s default build rules will not
scale to millions-of-lines codebases. It is however used in
countless useful libraries and projects where this has not been
a limitation.</p></li>
</ul>


<p>Some alternatives for building OCaml projects are:</p>

<ul>
<li><a href="https://github.com/mmottl/ocaml-makefile">OCaml-Makefile</a>,
a generic set of Makefile rules for OCaml projects. Valuable if you
want to build OCaml projects with <code>make</code>, without rewriting your own
boilerplate from scratch.</li>
<li><a href="http://omake.metaprl.org/index.html">OMake</a>, a generic build system
that has been succesfully used by several relatively large OCaml
projects.</li>
<li><a href="https://github.com/janestreet/jenga">jenga</a>, a build tool developed
internally at Jane Street. The design is interestingly close to
OCamlbuild&rsquo;s, but with large engineering efforts oriented towards
building their huge internal codebase. There is no easy-to-use
frontend layer provided to build OCaml projects
(and little documentation), it&rsquo;s more of
a build-your-own-build-system toolkit for now.</li>
<li><a href="https://github.com/ocaml-obuild/obuild">obuild</a> wants to be
a really-simple build system with a declarative configuration
language that has 80% the features, to cover most simple projects.</li>
</ul>


<p>The &ldquo;Real World OCaml&rdquo; book uses a tool named <code>corebuild</code>&mdash;which is in
fact just a simple wrapper on top of <code>ocamlbuild</code> provided by the
OCaml library named <code>core</code>&mdash;with some common options for <code>core</code>
projects baked in.</p>

<a name="Core.concepts..a.id..intro-core-concepts....a."></a>
<h2>Core concepts <a id="intro-core-concepts"></a></h2>

<a name="Rules.and.targets..a.id..concept-rules-targets....a."></a>
<h3>Rules and targets <a id="concept-rules-targets"></a></h3>

<p>OCamlbuild knows about a set of <em>rules</em> to build programs, that
provide a piece of OCaml code to build certain kinds of files, named
<em>targets</em>, from some dependencies (statically known or
dynamically discovered). For example, a built-in &ldquo;%.ml -> %.cmo&rdquo; rule
describes how to build any <code>.cmo</code> compilation unit file from the <code>.ml</code>
of the same name; if you call <code>ocamlbuild foo.cmo</code>, it will either use
<code>foo.ml</code> in your source directory or, if it doesn&rsquo;t exist, try to
build it, for example from <code>foo.mll</code> or <code>foo.mly</code>.</p>

<p>OCamlbuild knows various targets to build all sorts of useful things:
byte or native programs (<code>.byte</code>, <code>.native</code>), library archives
(<code>.cma</code>, <code>.cmxa</code>, <code>.cmxs</code>), documentation (<code>.docdir/index.html</code>,
<code>.docdir/man</code>), etc. We will detail these in the <a href="#reference-targets">Reference
section</a>.</p>

<a name="Tags.and.the..code._tags..code..file..a.id..concept-tags....a."></a>
<h3>Tags and the <code>_tags</code> file <a id="concept-tags"></a></h3>

<p><em>Tags</em> are an abstraction layer designed to specify command-line flags
in a declarative style. If you&rsquo;re invoking the compiler directly and
wish to build a program with debug information enabled, you need to pass
the <code>-g</code> flag to the compilation and linking step of the build
process, but not during an initial syntactic preprocessing step
(if any), when building <code>.cma</code> library archives, or when calling
<code>ocamldoc</code>. With OCamlbuild, you can simply add the <code>debug</code> tag to
your program&rsquo;s targets, and it will sort out when to insert the <code>-g</code>
flag or not.</p>

<p>To attach tags to your OCamlbuild targets, you write them in an <code>_tags</code>
file. Each line is of the form <code>foo: bar</code>, where <code>bar</code> is a list of tags,
and <code>foo</code> is a filter that determines which targets <code>bar</code>
applies to. For example the <code>_tags</code> file</p>

<pre><code>true: package(toto), package(tata)
&lt;foo.*&gt; or &lt;bar.*&gt;: debug
"strange.ml": rectypes
</code></pre>

<p>will make your whole project (<code>true</code> matches anything) depend on the
ocamlfind packages <code>toto</code> and <code>tata</code>, compile modules <code>foo</code> and <code>bar</code>
with debug information, and pass <code>-rectypes</code> when compiling
<code>strange.ml</code> &ndash; but not <code>strange.mli</code>. We will detail the <a href="#reference-tags-file">syntax of
predicates</a>, and the set of <a href="#reference-tags">built-in
tags</a> in the Reference section.</p>

<a name="L.code.myocamlbuild.ml..code...a.id..concept-myocamlbuild....a."></a>
<h3><code>myocamlbuild.ml</code> <a id="concept-myocamlbuild"></a></h3>

<p>The <code>_tags</code> file provides a convenient but limited interface to tune
your project. For any more general purpose, we chose to use
a configuration file directly written in OCaml, instead of reinventing
a home-made configuration language &ndash; or using your shell as Make
does. Code put in the <code>myocamlbuild.ml</code> file at the root of your
project will be compiled and executed by <code>ocamlbuild</code> upon invocation.</p>

<p>For simple use cases, you should not have to write a <code>myocamlbuild.ml</code>
file, except maybe to specify project-wide configuration options &ndash;
similar to command-line options you would pass to OCamlbuild. But it
also allows to define new rules and targets (for example to support
a shiny new preprocessing program), to define new tags or refine the
meaning of existing tags. We will cover these use-cases in the more
advanced <a href="#plugins">Plugin section</a> of the manual.</p>

<a name="A.simple.program..a.id..intro-example....a."></a>
<h2>A simple program <a id="intro-example"></a></h2>

<p>Simple OCaml projects often have a set of <code>.ml</code> and <code>.mli</code> files that
provide useful modules depending on each other, and possibly a main
file <code>myprog.ml</code> that contains the main program code.</p>

<pre><code>mod1.ml
mod1.mli
mod2.ml
myprog.ml
</code></pre>

<p>You can build your program using either the bytecode compiler, with</p>

<pre><code>% ocamlbuild myprog.byte
</code></pre>

<p>or the native compiler, with</p>

<pre><code>% ocamlbuild myprog.native
</code></pre>

<p>Let&rsquo;s look at the organization of your source directory after this
compilation command:</p>

<pre><code>_build/
mod1.ml
mod1.mli
mod2.ml
myprog.byte -&gt; _build/myprog.byte*
myprog.ml
</code></pre>

<p>OCamlbuild does all its work in a single <code>_build</code> directory, to help
keep your source directory clean. Targets are therefore built inside
<code>_build</code>. It will generally add a symbolic link for the requested
target in the user directory, but if a target does not appear after
being built, chances are it is in <code>_build</code>.</p>

<a name="Hygiene..a.id..intro-hygiene....a."></a>
<h2>Hygiene <a id="intro-hygiene"></a></h2>

<p>A more irritating feature is that it will actively complain if some
compiled files are left in the source directory.</p>

<pre><code>% ocamlc -c mod2.ml       # in the source directory of the previous example
% ocamlbuild myprog.byte

  SANITIZE: a total of 2 files that should probably not be in your
    source tree has been found. A script shell file
    "_build/sanitize.sh" is being created.  Check this script and
    run it to remove unwanted files or use other options (such as
    defining hygiene exceptions or using the -no-hygiene option).
  IMPORTANT: I cannot work with leftover compiled files.
  ERROR: Leftover OCaml compilation files:
    File mod2.cmo in . has suffix .cmo
    File mod2.cmi in . has suffix .cmi
  Exiting due to hygiene violations.

% rm mod2.cm*
</code></pre>

<p>It is possible to exclude some files from this hygiene checking by
tagging them with the <code>precious</code> or <code>not_hygienic</code> tags, or to disable
the check globally using the <code>-no-hygiene</code> command-line option.</p>

<p>The reason for this check is that leftover intermediate files can
disrupt the way your build system work. OCamlbuild knows which target
you need (library archives or program executables), and tries to build
their dependencies, which first builds the dependencies of those
dependencies, etc., until it eventually reaches your source files (the
<em>inputs</em> of the build process). Everything present in the source
directory is considered to be an input; if you keep old <code>.cmo</code> files
in your source repository, OCamlbuild will not try to rebuild them
from source files, but take them as references to produce the final
targets, which is not what you want if they are stale.</p>

<a name="OCamlfind.packages..a.id..intro-ocamlfind....a."></a>
<h2>OCamlfind packages <a id="intro-ocamlfind"></a></h2>

<p>Your project will probably depend on external libraries as well. Let&rsquo;s
assume they are provided by the ocamlfind packages <code>tata</code> and
<code>toto</code>. To tell OCamlbuild about them, you should use the tags
<code>package(tata)</code> and <code>package(toto)</code>. You also need to tell OCamlbuild
to enable support for ocamlfind by passing the <code>-use-ocamlfind</code>
command-line option.</p>

<p>So you will have the following <code>_tags</code> file:</p>

<pre><code>true: package(tata), package(toto)
</code></pre>

<p>and invoke compilation with</p>

<pre><code>ocamlbuild -use-ocamlfind myprog.byte
</code></pre>

<p>Note: given the pervasiveness of ocamlfind package, you can expect to
always invoke <code>ocamlbuild</code> with the <code>-use-ocamlfind</code> option. We will
probably enable <code>-use-ocamlfind</code> by default in future versions of
OCamlbuild, but in the meantime feel free to define a shell alias for
convenience.</p>

<p>Note 2: If you have a <a href="#Enriching%20OCamlbuild%20through%20plugins"><code>myocamlbuild.ml</code></a> file at the root of your OCamlbuild
project, you can use it to set this option, instead of using one command line parameter. Something like this:</p>

<pre><code>open Ocamlbuild_plugin
let () =
  dispatch (function
    | Before_options -&gt;
      Options.use_ocamlfind := true
    | _ -&gt; ())
</code></pre>

<a name="Syntax.extensions..a.id..intro-preproc....a."></a>
<h2>Syntax extensions <a id="intro-preproc"></a></h2>

<p>If you use syntax extensions distributed through <code>ocamlfind</code>, you can
use them as any ocamlfind package, but you must also use the
<code>syntax(...)</code> tag to indicate which preprocessor you use: <code>camlp4o</code>,
<code>camlp4r</code>, <code>camlp5o</code>, etc.</p>

<pre><code>true: syntax(camlp4o)
true: package(toto), package(blah.syntax)
</code></pre>

<p>In recent versions of OCamlbuild (since OCaml 4.01), you can also
specify this using the <code>-syntax</code> command-line option:</p>

<pre><code>ocamlbuild -use-ocamlfind -syntax camlp4o myprog.byte
</code></pre>

<p>Note that passing the option <code>-tag "syntax(camlp4o)"</code> will also work
in older versions. More generally, <code>-tag foo</code> will apply the tag <code>foo</code>
to all targets, it is equivalent to adding <code>true: foo</code> in your tag
line. Note that the quoting, <code>-tag "syntax(camlp4o)"</code> instead of
<code>-tag syntax(camlp4o)</code>, is necessary for your shell to understand tags
that have parentheses.</p>

<p>If you use <code>-ppx</code> preprocessors, you can use the parametrized tag
<code>ppx(...)</code> (<code>-tag "ppx(...)"</code>) to specify the preprocessor to use.</p>

<a name="Archives..documentation.....a.id..intro-archive-doc....a."></a>
<h2>Archives, documentation&hellip; <a id="intro-archive-doc"></a></h2>

<p>Some OCamlbuild features require you to add new kind of files in your
source directory. Suppose you would like to distribute an archive file
<code>mylib.cma</code> that would contain the compilation unit for your modules
<code>mod1.ml</code> and <code>mod2.ml</code>. For this, you should create a file
<code>mylib.mllib</code> listing the name of desired modules &ndash; capitalized, as
in OCaml source code:</p>

<pre><code>Mod1
Mod2
</code></pre>

<p>OCamlbuild knows about a rule <code>"%.mllib -&gt; %.cma"</code>, so you can then
use:</p>

<pre><code>ocamlbuild mylib.cma
</code></pre>

<p>or, for a native archive</p>

<pre><code>ocamlbuild mylib.cmxa
</code></pre>

<p>(Producing a shared native library <code>.cmxs</code> is also supported by
a different form of file with the same syntax, <code>foo.mldylib</code>)</p>

<p>Similarly, if you want to invoke <code>ocamldoc</code> to document your program,
you should list the modules you want documented in a <code>.odocl</code> file. If
you name it <code>mydoc.odocl</code> for example, you can then invoke</p>

<pre><code>ocamlbuild mydoc.docdir/index.html
</code></pre>

<p>which will produce the documentation in the subdirectory
<code>mydoc.docdir</code>, thanks to a rule <code>"%.odocl -&gt; %.docdir/index.html"</code>.</p>

<a name="Source.and.build.directories..module.paths..include.paths..a.id..intro-paths....a."></a>
<h2>Source and build directories, module paths, include paths <a id="intro-paths"></a></h2>

<p>The &ldquo;source directories&rdquo; that ocamlbuild will traverse to look for
rule dependencies are a subset of the subdirectory tree rooted at the
&ldquo;root directory&rdquo;, the place where you invoke ocamlbuild. (All the
paths we will discuss in this section are relative to the root
directory.)</p>

<p>The build directory contains a copy of the source directories
hierarchy, with the source file imported and additional targets
produced during the previous builds. It is traditionally the
subdirectory <code>_build</code> of the root directory, although this can be set
with the <code>-build-dir</code> command-line option. The build directory is not
part of the source directories considered by OCamlbuild.</p>

<p>A subdirectory of the subdirectory tree is included in the source
directories if it has the &ldquo;traverse&rdquo; tag set. That means that if you
want to add &ldquo;foo/bar&rdquo; (and its files) as part of the source
directories and remove &ldquo;foo/baz&rdquo;, you can use the following in your
<code>_tags</code> file:</p>

<pre><code>"foo/bar": traverse
"foo/baz": -traverse
</code></pre>

<p>If the option <code>-r</code> (for &ldquo;recursive&rdquo;) is passed, then by all
subdirectories (recursively) are considered part of the source
directories by default &ndash; except the build directory, and directories
that look like version-control information (<code>.svn</code>, <code>.bzr</code>, <code>.hg</code>,
<code>.git</code>, <code>_darcs</code>).</p>

<p>This option is enabled by default <em>if</em> the root directory looks like
an ocamlbuild project: either a <code>myocamlbuild.ml</code> or a <code>_tags</code> file is
present. (The reason for this heuristic is that calling <code>ocamlbuild</code>
from your home directory could take a very long time if it recursively
traverses your subdirectories, to check for hygiene for example.) If
the root directory does not look like an ocamlbuild project, but you
still wish to use it as such, you can just add the <code>-r</code> option
explicitly. In the other direction, you can explicitly disable
recursive traverse with <code>true: -traverse</code> in your <code>_tags</code> file.</p>

<a name="Module.paths.and.include.directories..a.id..paths-module-include....a."></a>
<h3>Module paths and include directories <a id="paths-module-include"></a></h3>

<p>On many occasions OCamlbuild needs you to indicate compilation units
(set of source and object files for a given OCaml module) located
somewhere in the source directories. The syntax to do this is to use
an OCaml module name (in particular, capitalized), prefixed by the
relative path from the root directory. For example, <code>bar/baz/Foo</code> will
work with the files <code>bar/baz/[fF]oo.{ml[i],cm*}</code>, depending on the
compilation phase.</p>

<p>For added convenience, it is possible to add a source directory to the
set of &ldquo;include paths&rdquo;, that do not have to be explicitly written in
each module path. If <code>bar/</code> is in the include path, you can refer to
<code>bar/baz/Foo</code> as just <code>baz/Foo</code>. To add <code>bar</code> to the include path, one
can pass the <code>-I bar</code> option to ocamlbuild, or tag <code>"bar": include</code>
in the <code>_tags</code> file.</p>

<p>(I have to come see the use of the same syntax <code>-I foo</code> in
<code>ocamlbuild</code> and in OCaml compilers as a mistake, because the
underlying concepts are rather different. In particular, it is <em>not</em>
the case that passing <code>-I foo</code> to ocamlbuild will transfer this
command-line option to underlying compiler invocation; if <code>foo</code> is
inside the source directories, this should not be needed, and if it is
outside you are encouraged to rely on ocamlfind packages instead of
absolute paths.)</p>

<a name="Reference.documentation..a.id..reference....a."></a>
<h1>Reference documentation <a id="reference"></a></h1>

<p>In this chapter, we will try to cover the built-in targets and tags
provided by OCamlbuild. We will omit features that are deprecated,
because we found they lead to bad practices or were superseded by
better options. Of course, given that a <code>myocamlbuild.ml</code> can add new
rules and tags, this documentation will always be partial.</p>

<a name="File.extensions.of.the.OCaml.compiler.and.common.tools..a.id..reference-compilre-extensions....a."></a>
<h2>File extensions of the OCaml compiler and common tools <a id="reference-compilre-extensions"></a></h2>

<p>A large part of the file extensions in OCamlbuild rules have not been
designed by OCamlbuild itself, but are standard extensions manipulated
by the OCaml compiler. As the reader may not be familiar with them, we
will recapitulate them now. For most use-cases OCamlbuild will hide
most of those subtleties from you, but having this reference is still
useful to understand advanced usage scenarios or read build logs.</p>

<ul>
<li><p><code>foo.ml</code>: OCaml source code, providing the implementation of the module <code>Foo</code></p></li>
<li><p><code>foo.mli</code>: OCaml source code, providing the interface of the module
<code>Foo</code></p></li>
<li><p><code>foo.cmo</code>: OCaml bytecode-compiled object file, providing the
implementation of the module <code>Foo</code></p></li>
<li><p><code>foo.cmi</code>: OCaml bytecode-compiled object file, providing the
interface of the module <code>Foo</code></p></li>
<li><p><code>blah.cma</code>: OCaml bytecode-compiled archive file, containing
a collection of <code>.cmo</code> or <code>.cma</code> files, to be used as a library
(for either static or dynamic linking)</p></li>
<li><p><code>foo.cmx</code>: OCaml native-compiled object file, providing the
implementation of the module <code>Foo</code></p></li>
<li><p><code>foo.o</code> (<code>foo.obj</code> under Windows): complementary native object file
for the module <code>Foo</code></p></li>
<li><p><code>foo.cmxa</code>: OCaml native-compiled archive file, containing
a collection of <code>.cmx</code> files, for static linking only</p></li>
<li><p><code>foo.a</code> or <code>foo.lib</code>: complementary native library files for
a native-compiled archive file <code>foo.cmxa</code>, containing a collection
of <code>.o</code> or <code>.obj</code> files</p></li>
<li><p><code>foo.cmxs</code>: OCaml native-compiled archive file (or &ldquo;plugin&rdquo;) for
dynamic linking, containing a collection of <code>.cmx</code>, <code>.cmxa</code>,
<code>.o|.obj</code>, <code>.a|.lib</code> files.</p></li>
</ul>


<p>The OCaml compilers also accept native files (<code>.o|.obj</code>, <code>.a|.lib</code> and
even source files <code>.c</code>) as input arguments, which get passed to the
native C toolchain (compiler or linker) when producing mixed C/OCaml
programs or libraries.</p>

<p>In addition, the following extensions are not enforced by the compiler
itself, but are commonly used by OCaml tools:</p>

<ul>
<li><p><code>foo.mll</code>: lexer description, to be processed by a lexer generator
to produce a <code>foo.ml</code> file, and possibly <code>foo.mli</code></p></li>
<li><p><code>foo.mly</code>: grammar description, to be processed by a parser
generator to produce a <code>foo.ml</code> file, and possibly <code>foo.mli</code></p></li>
<li><p><code>foo.mlp</code>, <code>foo.ml4</code>, <code>foo.mlip</code>, <code>foo.mli4</code>: common extensions for
files to be processed by an external preprocessor (<code>p</code> for
&ldquo;preprocessing&rdquo; and <code>4</code> for Camlp4, an influential
OCaml preprocessor).</p></li>
</ul>


<a name="Targets.and.rules..a.id..reference-targets....a."></a>
<h2>Targets and rules <a id="reference-targets"></a></h2>

<p>The built-in OCamlbuild for OCaml compilation all rely on file
extensions to know which rule to use. Note that this is not imposed by
OCamlbuild rule system, which would allow more flexible patterns. But
it is always the filename of the target that determines which rules to
apply to build it.</p>

<p>In consequence, OCamlbuild adds specific file extensions to the one
listed above (or variations of them), that are the user-interface to
use its rules providing certain features. For example, <code>.inferred.mli</code>
is not a standard extension in the OCaml compiler, but it is
understood by a built-in rule of OCamlbuild to ask for the <code>.mli</code> that
the compiler can auto-generate by typing a <code>.ml</code> file without an
explicit interface: running <code>ocamlbuild foo.inferred.mli</code> will first
build <code>foo.ml</code> (or find it in the source directory), then generate
<code>foo.inferred.mli</code> from it &ndash; users are expected to then inspect it,
hopefully add documentation, and then move it to <code>foo.mli</code> by
themselves.</p>

<p>The target extensions understood by OCamlbuild built-in rules are
listed in the following subsections. Again, note that <code>myocamlbuild</code>
plugins may add new targets and rules.</p>

<a name="Basic.targets..a.id..targets-basics....a."></a>
<h3>Basic targets <a id="targets-basics"></a></h3>

<ul>
<li><p><code>.cmi</code>, <code>.cmo</code>, <code>.cmx</code>: builds those intermediate files from the
corresponding source files (<code>.ml</code>, and the <code>.mli</code> if it exists)</p></li>
<li><p><code>.byte</code>, <code>.native</code>: extension of executables generated from a module
and its dependencies for bytecode and native compilation.</p></li>
<li><p><code>.mllib</code>: contains a list of module paths (<code>Bar</code>, <code>subdir/Baz</code>) that
will be compiled and archived together to build a corresponding <code>.cma</code>
or <code>.cmxa</code> target.</p></li>
<li><p><code>.cma</code>, <code>.cmxa</code>: the preferred way to build a library archive is to
use a <code>.mllib</code> file listing its content. If a <code>foo.mllib</code> is absent,
building the target <code>foo.cm{,x}a</code> will create an archive with
<code>foo.cm{o,x}</code> and all the local module it depends upon,
transitively.</p></li>
<li><p><code>.mldylib</code>: contains a list of module paths (<code>Bar</code>, <code>subdir/Baz</code>)
that will be compiled and archived together to build a corresponding
<code>.cmxs</code> target (native plugin). Note that there is no corresponding
concept of bytecode plugin archive, as <code>.cma</code> files (built from
<code>.mllib</code> files) support for static and dynamic linking.</p></li>
<li><p><code>.cmxs</code>: the preferred way to build a plugin archive is to list its
content in a <code>.mldylib</code> file. In absence of <code>foo.mldylib</code>,
building <code>foo.cmxs</code> will either:</p>

<ul>
<li><p>build <code>foo.cmxa</code> and copy its content into
a <code>.cmxs</code> file (in particular this means that a <code>.cmxs</code> can be
created from a <code>.mllib</code> file), or</p></li>
<li><p>build <code>foo.cmx</code> and create a plugin archive containing exactly
<code>foo.cmx</code>. Note that this differs from the rule for <code>.cm{,x}a</code>
files (whose archive include the dependencies of the module
<code>Foo</code>), in order to avoid dynamically linking the same modules
several times.</p></li>
</ul>
</li>
<li><p><code>.itarget</code>, <code>.otarget</code>: building <code>foo.itarget</code> requests the build of
the targets listed (one per line) in the corresponding <code>foo.itarget</code>
file</p></li>
</ul>


<a name="ocamldoc.targets..a.id..targets-ocamldoc....a."></a>
<h3>ocamldoc targets <a id="targets-ocamldoc"></a></h3>

<p>These target will call the documentation generator <code>ocamldoc</code>.</p>

<ul>
<li><p><code>.odocl</code>: contains a list of module names for which to produce
documentation, using one of the targets listed below</p></li>
<li><p><code>.docdir/index.html</code>: building the target
<code>foo.docdir/index.thml</code> will create a subdirectory <code>foo.docdir</code>
containing the HTML documentation of all modules listed in
<code>foo.odocl</code>.</p></li>
<li><p><code>.docdir/man</code>: as <code>.docdir/index.html</code> above, but builds the
documentation in <code>man</code> format</p></li>
<li><p><code>.docdir/bar.tex</code> or <code>.docdic/bar.ltx</code>: building the target
<code>foo.docdir/bar.tex</code> will build the documentation for the modules
listed in <code>foo.odocl</code>, as a LaTeX file named
<code>foo.docdir/bar.tex</code>. The basename <code>bar</code> is not important, but it is
the extension <code>.tex</code> or <code>.ltx</code> that indicates to OCamlbuild that
ocamldoc should be asked for a LaTeX output.</p></li>
<li><p><code>.docdir/bar.texi</code>: same as above, but generates documentation in
TeXinfo format.</p></li>
<li><p><code>.docdir/bar.dot</code>: same as above, but generates a <code>.dot</code> graph of
inter-module dependencies.</p></li>
</ul>


<a name="OCamlYacc.and.Menhir.targets..a.id..targets-parsegen....a."></a>
<h3>OCamlYacc and Menhir targets <a id="targets-parsegen"></a></h3>

<p>OCamlbuild will by default use <code>ocamlyacc</code>, a legacy parser generator
that is included in the OCaml distribution. The third-party parser
generator <a href="http://gallium.inria.fr/~fpottier/menhir/">Menhir</a> is
superior in all aspects, so you are encouraged to use it instead. To
enable the use of Menhir instead of ocamlyacc, you should pass the
<code>-use-menhir</code> option, or have <code>true: use_menhir</code> in your <code>_tags</code>
file. OCamlbuild will then activate menhir-specific builtin rule
listed below.</p>

<ul>
<li><p><code>.mly</code> files are grammar description files. They will be passed to
OCamlYacc to produce the corresponding <code>.ml</code> file, or Menhir if it
is enabled.</p></li>
<li><p><code>.mlypack</code>: Menhir (not ocamlyacc) supports building a parser by
composing several <code>.mly</code> files together, containing different parts
of the grammar description. Listing module paths in <code>foo.mlypack</code>
will produce <code>foo.ml</code> and <code>foo.mli</code> by combining the <code>.mly</code> files
corresponding to the listed modules.</p></li>
<li><p><code>.mly.depends</code> and <code>.mlypack.depends</code>: Menhir (not ocamlyacc)
supports calling <code>ocamldep</code> to approximate the dependencies of the
OCaml module on which the generated parser will depend.</p></li>
</ul>


<a name="Advanced.targets"></a>
<h3>Advanced targets</h3>

<ul>
<li><p><code>.ml.depends</code>, <code>.mli.depends</code>: call the <code>ocamldep</code> tool to compute
a conservative over-approximation of the external dependencies of the
corresponding source file</p></li>
<li><p><code>.inferred.mli</code>: infer a <code>.mli</code> interface from the corresponding
<code>.ml</code> file</p></li>
<li><p><code>.mlpack</code>: contains a list of module paths (<code>Bar</code>, <code>subdir/Baz</code>)
that can be packed as submodules of a <code>.cmo</code> or <code>.cmx</code> file: if
<code>foo.mlpack</code> exist, asking for the target <code>foo.cmx</code> will build the
modules listed in <code>foo.mlpack</code> and pack them together. Note that the
native OCaml compiler requires the submodules that will be packed to
be compiled with the <code>-for-pack Foo</code> option (where <code>Foo</code> is the name
of the result of packing), and OCamlbuild does not hide this
semantics from the user: you can use the built-in parametrized flag
<code>for-pack(Foo)</code> for this purpose. For example, to build <code>foo.cmx</code>
containing <code>Bar</code> and <code>subdir/Baz</code> as packed-submodules, you should
have the following:</p>

<pre><code>  foo.mlpack:
    Bar
    subdir/Baz

  _tags:
    &lt;{bar,subdir/baz}.cmx: for-pack(Foo)
</code></pre></li>
<li><p><code>.byte.o</code> (<code>.byte.obj</code> on Windows), <code>.byte.so</code> (<code>.byte.dll</code> on
Windows, <code>.byte.dylib</code> on OSX), <code>.byte.c</code>: produces object files for
static or dynamic linking, or a C source file, by passing the
<code>-output-obj</code> option to the OCaml bytecode compiler &ndash; see
<code>-output-obj</code> documentation.</p></li>
<li><p><code>.native.(o|obj)</code>, <code>.native.(so|dll|dylib)</code>:
produces object files for static or dynamic linking by passing the
<code>-output-obj</code> option to the OCaml native compiler &ndash; see
<code>-output-obj</code> documentation.</p></li>
<li><p><code>.c</code>, <code>.{o,obj}</code>: OCamlbuild can build <code>.{o,obj}</code> files from <code>.c</code>
files by passing them to the OCaml compiler (which in turns calls
the C toolchain). The OCaml compiler called is <code>ocamlc</code> or
<code>ocamlopt</code>, depending on whether or not the <code>native</code> flag is set on
the <code>.c</code> source file.</p></li>
<li><p><code>.clib</code>: contains a list of file paths (eg. <code>foo.o</code>, not
module paths) to be linked together (by using the standard
<code>ocamlmklib</code> tool) to produce a <code>.a</code> or <code>.lib</code> archive
(for static linking) or a <code>.so</code> or <code>.dll</code> archive
(for dynamic linking). The .clib name should be prefixed by <code>lib</code>,
and the target name will then a <code>lib</code> or <code>dll</code> prefix, following
standard conventions: to build a static library from <code>libfoo.clib</code>,
you should require the target <code>libfoo.{a,lib}</code>, and to build
a dynamic library you should require the target
<code>dllfoo.{so,dll}</code>. If <code>foo.o</code> is listed and OCamlbuild is run from
Windows, <code>foo.obj</code> will be used instead.</p></li>
<li><p><code>.mltop</code>, <code>.top</code>: requesting the build of <code>foo.top</code> will look for
a list of module paths in <code>foo.mltop</code>, and build a custom toplevel
with all these modules pre-linked &ndash; by using the standard
<code>ocamlmktop</code> tool.</p></li>
</ul>


<a name="Deprecated.targets..a.id..targets-deprecated....a."></a>
<h3>Deprecated targets <a id="targets-deprecated"></a></h3>

<ul>
<li><p><code>.p.*</code>, <code>.d.*</code>:</p>

<p>  OCamlbuild supports requesting <code>foo.p.{cmx,native}</code> and
  <code>foo.d.{cmo,byte}</code> to build libraries or executables with profiling
  information (<code>.p</code>) or debug information (<code>.d</code>) enabled. Unfortunately,
  this runs counter the simple scheme used by the OCaml compiler to find
  the object files of a compilation unit dependencies: if <code>Foo</code> depends
  on a module <code>Bar</code>, the compilation of <code>foo.p.cmx</code> will inspect
  <code>bar.cmx</code> (rather than <code>bar.p.cmx</code>) for cross-module information &ndash;
  this is why <code>.d</code> is not supported for native code, as this defeats the
  purpose of debug builds. (<code>.p</code> is not supported for bytecode because
  bytecode profiling works very differently from native profiling.).</p>

<p>  The more robust solution is to build <code>foo.{cmo,cmx,byte,native}</code> with
  the <code>profile</code> or <code>debug</code> flag set (eg. <code>ocamlbuild -tag debug
  foo.native</code>, or using the <code>_tags</code> file). If the flag is set for
  certain files only, only those will have debugging or profiling
  information enabled. Note that (contrarily to the <code>.d.cmx</code> approach)
  this means you cannot keep a both a with-debug-info and
  a without-debug-info compiled object file for the same module at the
  same time: building <code>foo.byte</code> with <code>true: debug</code>, then without
  (or conversely) will rebuild all the <code>.cmo</code> files of all of <code>foo</code>
  dependencies each time.</p></li>
<li><p><code>.pp.ml</code>: This target produces a pretty-printing (as OCaml
source code) of the OCaml AST produced by preprocessing the
corresponding <code>.ml</code> file. This does not work properly when using
<code>ocamlfind</code> to activate Camlp4 preprocessors (the now-preferred way
to enable syntax extensions), because <code>ocamlfind</code> does not provide
a way to obtain the post-processing output, only to preprocess
during compilation. Note that passing the <code>-dsource</code> compilation
flag to the OCaml compiler will make it emit the result
post-processing during compilation (as OCaml source code; use
<code>-dparsetree</code> for a tree view of the AST).</p></li>
</ul>


<a name="Tags..a.id..reference-tags....a."></a>
<h2>Tags <a id="reference-tags"></a></h2>

<a name="Basic.tags..a.id..tags-basics....a."></a>
<h3>Basic tags <a id="tags-basics"></a></h3>

<p>For convenience, we try to have a tag for each setting exported as
command-line parameters by the OCaml compilers and tools. A builtin
tag <code>foo_bar</code> corresponding to the option <code>-foo-bar</code> is in general
better than trying to pass <code>-cflags -foo-bar</code> to the ocamlbuild
compilation command, as it can enable the <code>-foo-bar</code> flag only when it
make sense, in a more fine-grained way that &ldquo;during a compilation
command&rdquo;.</p>

<p>(If you notice that a compiler-provided command-line option is missing
its tag counterpart, this is a bug that you should report against
ocamlbuild. Feel free to look at the implementation and send a patch
adding this tag, it is really easy.)</p>

<ul>
<li><p>compiler options:</p>

<ul>
<li><code>absname</code></li>
<li><code>annot</code></li>
<li><code>asm</code> (for ocamlopt&rsquo;s <code>-S</code>)</li>
<li><code>bin_annot</code></li>
<li><code>compat_32</code></li>
<li><code>custom</code></li>
<li><code>debug</code> (for <code>-g</code>)</li>
<li><code>dtypes</code></li>
<li><code>for-pack(PackModule)</code></li>
<li><code>inline(5)</code></li>
<li><code>keep_locs</code></li>
<li><code>linkall</code></li>
<li><code>no_alias_deps</code></li>
<li><code>no_float_const_prop</code></li>
<li><code>nolabels</code></li>
<li><code>nopervasives</code></li>
<li><code>opaque</code></li>
<li><code>open(MyPervasives)</code></li>
<li><code>output_obj</code></li>
<li><code>output_shared</code> (for <code>-cclib -shared</code>, automatically set by <code>.{byte,native}.{so,dll,dylib}</code> targets),</li>
<li><code>pp(my_pp_preprocessor)</code></li>
<li><code>ppx(my_ppx_preprocessor)</code></li>
<li><code>principal</code></li>
<li><code>profile</code> (for <code>-p</code>)</li>
<li><code>rectypes</code></li>
<li><code>runtime_variant(_pic)</code></li>
<li><code>safe_string</code></li>
<li><code>short_paths</code></li>
<li><code>strict_formats</code></li>
<li><code>strict_sequence</code></li>
<li><code>thread</code></li>
<li><code>unsafe_string</code></li>
<li><code>warn(A@10-28@40-42-45)</code></li>
<li><code>warn_error(+10+40)</code></li>
</ul>
</li>
<li><p>ocamlfind options:</p>

<ul>
<li><code>package(pkgname)</code></li>
<li><code>linkpkg</code></li>
<li><code>dontlink(pkgname)</code></li>
<li><code>predicate(foo)</code></li>
<li><code>syntax(bar)</code></li>
</ul>
</li>
<li><p>ocamllex options: <code>quiet</code> (<code>-q</code>), <code>generate_ml</code> (<code>-ml</code>)</p></li>
<li><p>menhir options: <code>only_tokens</code>, <code>infer</code>, <code>explain</code>, <code>external_tokens(TokenModule)</code></p></li>
<li><p>camlp4 options: <code>use_caml4_{,bin}</code>, <code>camlp4{rrr,orrr,oof,orf,rf,of,r,o}{,.opt}</code></p></li>
<li><p>deprecated: the commands
<code>use_{ocamlbuild,ocamldoc,toplevel,graphics,dbm,nums,bigarray,str,unix,dynlink}</code>
were designed to indicate that the tagged modules depend on the
corresponding libraries from the OCaml distributions
(<code>use_{ocamlbuild,ocamldoc,toplevel}</code> allows to compile against the
tools' libraries to build plugins). We now recommend to enable those
libraries through their corresponding ocamlfind package.</p></li>
<li><p>ocamlbuild-specific tags:</p>

<ul>
<li><p><code>not_hygienic</code> and <code>precious</code>: explicitly indicate that a file is
part of the source directory and should not be warned about by the
hygiene-checking tools. This is useful if for some reason you are
given, for example, a <code>.cmi</code> file to use unchanged in your
project.</p></li>
<li><p><code>traverse</code>: explicitly indicate that ocamlbuild should consider
this subdirectory as part of the current project; this flag is
set for all subdirectories by default (so OCamlbuild will look
in subdirectories recursively to find module dependencies) as
soon as the current directory &ldquo;looks like an OCamlbuild project&rdquo;
(there is either a <code>myocamlbuild.ml</code> or <code>_tags</code>
file present). This tag is usefully used negative,
<code>"foo": -traverse</code>, to say that a part of the local directory
hierarchy should <em>not</em> be considered by ocamlbuild.</p></li>
<li><p><code>include</code>, <code>traverse</code>: see the section above on source
directories and include paths.</p></li>
<li><p>global tags: setting <code>true: use_mehir</code> in the root <code>_tags</code> file
is equivalent to passing the <code>-use-menhir</code> command-line parameter.</p></li>
</ul>
</li>
</ul>


<a name="Advanced..context..tags..a.id..tags-advanced....a."></a>
<h3>Advanced (context) tags <a id="tags-advanced"></a></h3>

<p>These tags are generally not meant to be used directly in <code>_tags</code>
file, but rather to serve as the context part of tag declarations. For
example, the <code>link</code> flag is automatically added thet set of tags of
linking-related command, allowing tag declarations to add specific
flags during linking phase only &ndash; but it would make little sense to
explicitly add the <code>link</code> tag to a target in your <code>_tags</code> file.</p>

<ul>
<li><p>language context: <code>c</code> or <code>ocaml</code> indicate whether the compiler
invocation are working with OCaml files, or C files (to be passed to
the underlying C toolchain). If you wished to use OCamlbuild for
a completely different purpose (not necessarily OCaml-related), for
example building LaTeX documents, you could use a corresponding
<code>latex</code> tag</p></li>
<li><p>compilation stage context: <code>pp</code> (syntactic preprocessing), <code>compile</code>
(compilation of source files), <code>link</code> (linking of object files), but
also <code>pack</code> (when packing compiled object files), <code>library</code>
(when creating library archives), <code>infer_interface</code>
(producing a <code>.mli</code> from the corresponding <code>.ml</code>) and <code>toplevel</code>
(when building custom toplevels)</p></li>
<li><p>byte or native compilation context: <code>byte</code> (ocamlc) or <code>native</code> (ocamlopt)</p></li>
<li><p>extension tags: when building the target <code>foo.bar</code>, a tag
<code>extension:bar</code> is added to the set of current tags. This is used by
the builtin ocamldoc rules to enable either <code>-latex</code> or <code>-dot</code>
depending on the requested target extension.</p></li>
<li><p>tool-specific tags: <code>menhir</code>, <code>ocamlyacc</code>, <code>ocamllex</code>, <code>doc</code> (for ocamldoc)</p></li>
</ul>


<a name="The..code.-documentation..code..option..a.id..reference-documentation....a."></a>
<h2>The <code>-documentation</code> option <a id="reference-documentation"></a></h2>

<p>Invoking <code>ocamlbuild -documentation</code> will give a list of rules and
tags known to OCamlbuild in the current project (including those
defined in the <code>myocamlbuild</code> plugin). This is a good way to quickly
look for the tag name corresponding to a particular option, and also
more accurate than the above reference manual, which does cannot
describe plugin-specific features.</p>

<p>Note that this output is sensitive to the current configuration. For
example, <code>ocamlbuild -use-ocamlfind -documentation</code> and
<code>ocamlbuild -no-ocamlfind -documentation</code> produce different outputs,
as the latter does not include ocamlfind-specific tags.</p>

<p>Here is an example of rule documentation included in the
<code>ocamlbuild -documentation</code> output:</p>

<pre><code>rule "ocaml: modular menhir (mlypack)"
  ~deps:[ %.mlypack ]
  ~prods:[ %.mli; %.ml ]
  ~doc:"Menhir supports building a parser by composing several .mly files
        together, containing different parts of the grammar description. To
        use that feature with ocamlbuild, you should create a .mlypack file
        with the same syntax as .mllib or .mlpack files: a
        whitespace-separated list of the capitalized module names of the .mly
        files you want to combine together."
  &lt;fun&gt;
</code></pre>

<p>This resembles OCaml code (see the documentation of <a href="#plugins-new-rules">rule
declarations</a>), but is not valid OCaml code.</p>

<p>Note that rule declaration only indicate the static dependencies of
rules (those that determine whether or not the rule will
be tried). Remark that this rule is explicit about the fact that
invoking <code>menhir</code> produces both a <code>.ml</code> and <code>.mli</code>.</p>

<p>Here are example of tag declarations (parametrized tag are documented
since version 4.03).</p>

<pre><code>parametrized flag {. compile, ocaml, ppx(my_ppx) .} "-ppx my_ppx"

[...]

flag {. compile, no_alias_deps, ocaml .} "-no-alias-deps"
</code></pre>

<a name="Syntax.of..code._tags..code..file..a.id..reference-tags-file....a."></a>
<h2>Syntax of <code>_tags</code> file <a id="reference-tags-file"></a></h2>

<p>The <code>_tags</code> file associates file name patterns with tags like this:</p>

<pre><code># This is a comment
true: bin_annot, debug
&lt;protocol_*&gt; or &lt;main.*&gt;: package(yojson)
</code></pre>

<p>The general syntax is:</p>

<pre><code>{pattern}: {comma-separated tag list}
</code></pre>

<p>These items are ended by a newline. Comments (starting with <code>#</code>) and
empty lines are ignored, and an escaped line break is considered as
whitespace (so those items can span multiple lines).</p>

<p>The <code>{pattern}</code> part is what we call a &ldquo;glob expression&rdquo;, which is an
expression built of basic logic connective on top of &ldquo;glob
patterns&rdquo;.</p>

<p>The syntax of glob expressions is as follows:</p>

<table>
  <tr>
    <th>Syntax</th>
    <th>Example</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td><code>&lt;p&gt;</code></td>
    <td><code>&lt;foo.*&gt;</code></td>
    <td>paths matching the pattern <code>p</code></td>
  </tr>
  <tr>
    <td><code>"s"</code></td>
    <td><code>"foo/bar.ml"</code></td>
    <td>The exact string <code>s</code></td>
  </tr>
  <tr>
    <td><code>e1 or e2</code></td>
    <td><code>&lt;*.ml&gt; or &lt;foo/bar.ml&gt;</code></td>
    <td>Paths matching at least one of the expression <code>e1</code> or <code>e2</code></td>
  </tr>
  <tr>
    <td><code>e1 and e2</code></td>
    <td><code>&lt;*.ml&gt; and &lt;foo_*&gt;</code></td>
    <td>Paths matching both expressions <code>e1</code> and <code>e2</code></td>
  </tr>
  <tr>
    <td><code>not e</code></td>
    <td><code>not &lt;*.mli&gt;</code></td>
    <td>Paths not matching the expression <code>e</code></td>
  </tr>
  <tr>
    <td><code>true</code></td>
    <td><code>true</code></td>
    <td>All pathnames</td>
  </tr>
  <tr>
    <td><code>false</code></td>
    <td><code>false</code></td>
    <td>Nothing</td>
  </tr>
  <tr>
    <td><code>( e )</code></td>
    <td><code>( &lt;*&gt; and not &lt;*.*&gt; )</code></td>
    <td>Same as <code>e</code> (useful for composing larger expressoins)</td>
  </tr>
</table>


<p>The syntax of glob patterns is as follows:</p>

<table>
  <tr>
    <th>Syntax</th>
    <th>Example</th>
    <th>Matches</th>
    <th>Does not match</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td><code>s</code></td>
    <td><code>foo.ml</code></td>
    <td><code>foo.ml</code></td>
    <td><code>bar.ml</code></td>
    <td>The exact string <code>s</code></td>
  </tr>
  <tr>
    <td><code>*</code> (wildcard)</td>
    <td><code>*</code></td>
    <td>the empty path, <code>foo</code>, <code>bar</code></td>
    <td><code>foo/bar</code>, <code>/baz</code></td>
    <td>Any string not containing a slash <code>/</code></td>
  </tr>
  <tr>
    <td><code>?</code> (joker)</td>
    <td><code>?</code></td>
    <td><code>a</code>, <code>b</code>, <code>z</code></td>
    <td><code>/</code>, <code>bar</code></td>
    <td>Any one-letter string, excluding the slash <code>/</code></td>
  </tr>
  <tr>
    <td><code>**/</code> (prefix inter-directory wildcard)</td>
    <td><code>**/foo.ml</code></td>
    <td><code>foo.ml</code>, <code>bar/foo.ml</code>, <code>bar/baz/foo.ml</code></td>
    <td><code>foo/bar</code>, <code>/baz</code></td>
    <td>The empty string, or any string ending with a slash <code>/</code></td>
  </tr>
  <tr>
    <td><code>/**</code> (suffix inter-directory wildcard)</td>
    <td><code>foo/**</code></td>
    <td><code>foo</code>, <code>foo/bar</code></td>
    <td><code>bar/foo</code></td>
    <td>The empty string, or any string starting with a slash <code>/</code></td>
  </tr>
  <tr>
    <td><code>/**/</code> (infix inter-directory wildcard)</td>
    <td><code>bar/**/foo.ml</code></td>
    <td><code>bar/foo.ml</code>, <code>bar/baz/foo.ml</code></td>
    <td><code>foo.ml</code></td>
    <td>Any string starting and ending iwth a slash <code>/</code></td>
  </tr>
  <tr>
    <td><code>[r1 r2 r3...]</code> where a <code>r</code> is either a single character <code>c</code> or a range <code>c1-c2</code> (positive character class)</td>
    <td><code>[a-fA-F0-9_.]</code></td>
    <td><code>3</code>, <code>F</code>, <code>.</code></td>
    <td><code>z</code>, <code>bar</code></td>
    <td>Any one-letter string made of characters from one of the given ranges</td>
  </tr>
  <tr>
    <td><code>[^ r1 r2 r3...]</code> where a <code>r</code> is either a single character <code>c</code> or a range <code>c1-c2</code> (negative character class)</td>
    <td><code>[a-fA-F0-9_.]</code></td>
    <td><code>z</code>, <code>bar</code></td>
    <td><code>3</code>, <code>F</code>, <code>.</code></td>
    <td>Any one-letter string *not* made of characters from one of the
    given ranges</td>
  </tr>
  <tr>
    <td><code>p1 p2</code> (concatenation)</td>
    <td><code>foo*</code></td>
    <td><code>foo</code>, <code>foob</code>, <code>foobar</code></td>
    <td><code>fo</code>, <code>bar</td></td>
    <td>Any string with a (possibly empty) prefix matching the pattern
    <code>p1</code> and the (possibly empty) remainder matching the pattern <code>p2</code>.</td>
  </tr>
  <tr>
    <td><code>{ p1, p2, ... }</code> (union)</td>
    <td><code>toto.{ml,mli}</code></td>
    <td><code>toto.ml</code>, <code>toto.mli</code></td>
    <td><code>toto.</code></td>
    <td>Any string matching one of the given patterns.</td>
  </tr>
</table>


<p>In addition, rule patterns may include pattern variables. <code>%(foo: p)</code>
will match for the pattern <code>p</code> and name the result <code>%(foo)</code>. For
example, <code>%(path: &lt;**/&gt;)foo.ml</code> is useful. <code>%(foo)</code> will match the
pattern <code>true</code> and name the result <code>%(foo)</code>, and finally <code>%</code> will
match the pattern <code>true</code> and match the result <code>%</code>. Consider the
following examples:</p>

<pre><code>%.cmx
%(dir).docdir/%(file)
%(path:&lt;**/&gt;)lib%(libname:&lt;*&gt; and not &lt;*.*&gt;).so
</code></pre>

<a name="Enriching.OCamlbuild.through.plugins..a.id..plugins....a."></a>
<h1>Enriching OCamlbuild through plugins <a id="plugins"></a></h1>

<a name="How..code.myocamlbuild.ml..code..works..a.id..plugins-myocamlbuild-file....a."></a>
<h2>How <code>myocamlbuild.ml</code> works <a id="plugins-myocamlbuild-file"></a></h2>

<p>If you have a <code>myocamlbuild.ml</code> file at the root of your OCamlbuild
project, the building process will run in two steps.</p>

<p>First, OCamlbuild will compile that file, linking it with all the
modules that are part of the globally installed <code>ocamlbuild</code>
executable. This will produce a program <code>_build/myocamlbuild</code> that
behaves exactly like <code>ocamlbuild</code> itself, except that it also runs the
code of your <code>myocamlbuild.ml</code> file. Immediately after, OCamlbuild
will stop (before doing any work on the targets you gave it) and start
the <code>_build/myocamlbuild</code> program instead, that will handle the rest
of the job. This is quite close to how, for example, XMonad (a window
manager whose configuration files are pure Haskell) works.</p>

<p>This means that it is technically possible to do anything in
<code>myocamlbuild.ml</code> that could be done by adding more code to the
upstream OCamlbuild sources. But in practice, relying on the
implementation internals would be fragile with respect to OCamlbuild
version changes.</p>

<p>We thus isolated a subset of the OCamlbuild API, exposed by the
<code>Ocamlbuild_plugin</code> module, that defines a stable interface for plugin
writers. It lets you manipulate command-line options, define new rules
and targets, add new tags or refine the meaning of existing flags,
etc. The signature of this module is the <code>PLUGIN</code> module type of the
interface-only <code>signatures.mli</code> file of the OCamlbuild
distribution. It is littered with comments explaining the purpose of
the exposed values, but this documentation aspect can still be
improved. We warmly welcome patches to improve this aspect of
ocamlbuild &ndash; or any other aspect.</p>

<p>You can influence the <code>myocamlbuild.ml</code> compilation-and-launch process
in several ways:</p>

<ul>
<li><p>The <code>no-plugin</code> option allows to ignore the <code>myocamlbuild.ml</code> file
and just run the stock <code>ocamlbuild</code> executable on your project. This
mean that fancy new rules introduced by <code>myocamlbuild.ml</code> will not
be available.</p></li>
<li><p>The <code>-just-plugin</code> option instructs OCamlbuild to stop compilation
after having built the plugin; it also guarantees that OCamlbuild
will try to compile the plugin, which it may not always do, for
example when you only ask for cleaning or documentation.</p></li>
<li><p>The <code>-plugin-option FOO</code> option will pass the command-line option
<code>FOO</code> to the <code>myocamlbuild</code> invocation &ndash; and ignore it during
plugin compilation.</p></li>
<li><p>The <code>-plugin-tag</code> and <code>-plugin-tags</code> options allow to pass tags
that will be used to compile the plugin. For example, if someone
develops a cool library to help writing OCamlbuild plugins and
distribute as &lsquo;toto.ocamlbuild&rsquo; in ocamlfind, <code>-plugin-tag
"package(toto.ocamlbuild)"</code> will let you use it in your
<code>myocamlbuild.ml</code>.</p></li>
</ul>


<p>Note: the rationale for <code>-plugin-option</code> and <code>-plugin-tag</code> to apply
during different phases of the process is that an option is meaningful
at runtime for the plugin, while a plugin tag is meaningful at
compile-time.</p>

<a name="Dispatch..a.id..plugins-dispatch....a."></a>
<h2>Dispatch <a id="plugins-dispatch"></a></h2>

<p>Tag and rule declarations, or configuration option manipulation, are
side-effects that modify a global OCamlbuild state. It would be
fragile to write your <code>myocamlbuild.ml</code> with such side-effects
performed at module initialization time, in the following style</p>

<pre><code>open Ocamlbuild_plugin
(* bad style *)
let () =
  Options.ocamlc := "/better/path/to/ocamlc"
;;
</code></pre>

<p>The problem is that you have little idea, and absolutely no
flexibility, of the time at which those actions will be performed with
respect to all the other actions of OCamlbuild. In this example,
command-line argument parsing will happen after this plugin effect, so
the changed option would be overridden by command-line options, which
may or may not be what the plugin writer expects.</p>

<p>To alleviate this side-effect order issue, OCamlbuild lets you
register actions at hook points, to be called at a well-defined place
during the OCamlbuild process. If you want your configuration change
to happen after options have been processed, you should in fact write:</p>

<pre><code>open Ocamlbuild_plugin
let () =
  dispatch (function
    | After_options -&gt;
      Options.ocamlc := "..."
    | _ -&gt; ())
</code></pre>

<p>The <code>dispatch</code> function register a hook-listening function provided by
the user; its type is <code>(hook -&gt; unit) -&gt; unit</code>. The hooks are
currently defined as</p>

<pre><code>(** Here is the list of hooks that the dispatch function have to handle.
    Generally one responds to one or two hooks (like After_rules) and do
    nothing in the default case. *)
type hook =
  | Before_hygiene
  | After_hygiene
  | Before_options
  | After_options
  | Before_rules
  | After_rules
</code></pre>

<p>Note: we give no guarantee on the order in which various hooks will be
called, except of course that <code>Before_foo</code> always happens before
<code>After_foo</code>. In particular, the <code>hygiene</code> hooks may be called before
or after other hooks, or not be called at all if OCamlbuild decides
not to check <a href="#intro-hygiene">hygiene</a>.</p>

<a name="Flag.declarations..a.id..plugins-new-flags....a."></a>
<h2>Flag declarations <a id="plugins-new-flags"></a></h2>

<p>A flag declaration maps a <em>set of tags</em> to a list of command-line
options/flags/arguments. These arguments will be added to a given
compilation command if each of the tags are present on the given
target.</p>

<p>The following example can be found in <code>ocaml_specific.ml</code>, the file of
the OCamlbuild sources that defines most ocaml-specific tags and rules
of OCamlbuild:</p>

<pre><code>flag ["ocaml"; "annot"; "compile"] (A "-annot");
</code></pre>

<p>This means that the <code>-annot</code> command-line option is added to any
compilation command for which those three tags are present. The tags
<code>"ocaml"</code> and <code>"compile"</code> are activated by default by OCamlbuild,
<code>"ocaml"</code> for any ocaml-related command, and <code>"compile"</code> specifically
for compilation steps &ndash; as opposed to linking, documentation
generation, etc. The <code>"annot"</code> flag is not passed by default, so this
tag declaration will only take effects on targets that are explicitly
marked <code>annot</code> in the <code>_tags</code> file.</p>

<p>This very simple declarative language, mapping sets of tags to
command-line options, is the way to give meaning to OCamlbuild tags &ndash;
either add new ones or overload existing ones. It is very easy, for
example, to pass a different command-line argument depending on
whether byte or native-compilation is happening.</p>

<pre><code>flag ["ocaml"; "use_camlp4_bin"; "link"; "byte"]
  (A"+camlp4/Camlp4Bin.cmo");
flag ["ocaml"; "use_camlp4_bin"; "link"; "native"]
  (A"+camlp4/Camlp4Bin.cmx");
</code></pre>

<p>The <code>A</code> constructor stands for &ldquo;atom(ic)&rdquo;, and is part of a <code>spec</code>
datatype, representing specifications of fragments of command. We will
not describe its most advanced constructors &ndash; it is again exposed and
documented in <code>signatures.mli</code> &ndash; but the most relevant here are as
follow:</p>

<pre><code>(** The type for command specifications. That is pieces of command. *)
and spec =
  | N              (** No operation. *)
  | S of spec list (** A sequence.  This gets flattened in the last stages *)
  | A of string    (** An atom. *)
  | P of pathname  (** A pathname. *)
  [...]
</code></pre>

<p>Remark: when introducing new flags, it is sometime difficult to guess
which combination of tags to use. A hint to find the right combination
is to have a look at OCamlbuild&rsquo;s log file that is saved in
<code>_build/_log</code> each time ocamlbuild is run.  It contains the targets
OCamlbuild tried to produce, with the associated list of tags and the
corresponding command lines.</p>

<a name="Parametrized.tags..a.id..flags-parametrized....a."></a>
<h3>Parametrized tags <a id="flags-parametrized"></a></h3>

<p>You can also define families of parametrized tags such as
<code>package(foo)</code> or <code>inline(30)</code>. This is done through the <code>pflag</code>
function, which takes a list of usual tags, the special parametrized
tag, and a function from the tag parameter to the corresponding command
specification. Again from the <code>PLUGIN</code> module type in <code>signatures.mli</code>:</p>

<pre><code>(** Allows to use [flag] with a parametrized tag (as [pdep] for [dep]).

    Example:
       pflag ["ocaml"; "compile"] "inline"
         (fun count -&gt; S [A "-inline"; A count])
    says that command line option "-inline 42" should be added
    when compiling OCaml modules tagged with "inline(42)". *)
val pflag : Tags.elt list -&gt; Tags.elt -&gt; (string -&gt; Command.spec) -&gt; unit
</code></pre>

<a name="Rule.declarations..a.id..plugins-new-rules....a."></a>
<h2>Rule declarations <a id="plugins-new-rules"></a></h2>

<p>OCamlbuild let you build your own rules, to teach it how to build new
kind of targets. This is done by calling the <code>rule</code> function from
a plugin, which is declared and documented in the <code>PLUGIN</code> module in
<code>signatures.mli</code>. We will not write an exhaustive documentation here
(for this, have a look at <code>signatures.mli</code>), but rather expose the
most common features through representative examples.</p>

<p>Our first example is simple, as it is a rule without dynamic dependencies.</p>

<pre><code>rule "ocaml dependencies ml"
  ~prod:"%.ml.depends"
  ~dep:"%.ml"
  ~doc:"call ocamldep to compute a syntactic over-approximation \\
        of the dependencies of the corresponding implementation file"
  ocamldep_ml_command
</code></pre>

<p>The first string parameter is the name of the rule. This rule tells
OCamlbuild how to build <code>foo.ml.depends</code> from its <code>foo.ml</code>. The <code>%</code>
character here is a pattern variable: if the target name (for example
<code>foo.ml.depends</code>) matches the pattern of the rule production
<code>%.ml.depends</code>, OCamlbuild will try to build the static dependency of
the rule, which is the evaluation of <code>%.ml</code> in the pattern-matching
environment <code>% -&gt; "foo"</code> (that is, <code>foo.ml</code>). If this static
dependency can be built, then the &ldquo;action&rdquo; <code>ocamldep_ml_command</code> will
be invoked to produce the expected result.</p>

<p>The action, of type <code>PLUGIN.action</code>, is a function that takes the
current pattern-matching environment (in our example, mapping the
pattern variable <code>%</code> to <code>foo</code>), a builder function, and returns
a command, the command to execute to produce the final target of this
rule. The plugin author defining this rule should define the
<code>ocamldep_ml_command</code> as follows:</p>

<pre><code>let ocamldep_ml_command env _build =
  let arg = env "%.ml" and out = env "%.ml.depends" in
  let tags = tags_of_pathname arg ++ "ocaml" ++ "ocamldep" in
  Cmd(S[A "ocamldep"; T tags; A "-modules"; P arg; Sh "&gt;"; Px out])
</code></pre>

<p>The first line in this definition uses the pattern environment to
compute the actual name of the input and output files. These are then
passed in as arguments to the <code>ocamldep</code> command and shell redirect,
respectively, on the third line.
The environment type <code>PLUGIN.env</code> is just <code>string -&gt; string</code>, it takes
a pattern and substitutes its pattern variables to return a closed result.</p>

<p>The second line in this definition computes the tags to include in the
command invocation. When OCamlbuild is passed back the command, it uses
the tag declarations to determine which, if any, additional flags to
insert into the command invocation. The call <code>tags_of_pathname arg</code>
looks up in the <code>_tags</code> file any tags associated with file <code>foo.ml</code>.
To these tags the rule code also adds the two contextual tags <code>ocaml</code>
and <code>ocamldep</code> (on which flag declarations may depend).</p>

<p>Finally, the command is built:</p>

<pre><code>  Cmd(S[A "ocamldep"; T tags; A "-modules"; P arg; Sh "&gt;"; Px out])
</code></pre>

<p>We already mentioned above the constructors <code>S</code>, <code>A</code> and <code>P</code> of the
<code>command.spec</code> type: <code>S</code> just builds a sequence by concatenating
sequent fragments, <code>A</code> is used for &ldquo;atoms&rdquo; (fragments of text to be
included as-is, but may be escaped to not break shell syntax), and <code>P</code>
denotes a filesystem path that should be quoted.</p>

<p>The constructor <code>T</code> is used to embed tags within a command. Note
passing <code>T</code> twice, one with the tag set <code>ocaml, ocamldep</code> and the
other with the tag <code>foo</code>, is not equivalent to passing <code>ocaml,
ocamldep, foo</code> together, as the transformation of tags into flags
proceeds on each <code>T</code> fragment separately.</p>

<p><code>Sh</code> is used for bits of raw shell code that should not be quoted at
all, here the output redirection <code>&gt;</code>. Finally, <code>Px</code> indicates
a filesystem path just as <code>P</code>, but it adds the information that this
filesystem path is the path of the target produced by this rule &ndash;
this information is used by OCamlbuild for logging purposes.</p>

<a name="Remark:.tags.handling.in.rules"></a>
<h5>Remark: tags handling in rules</h5>

<p>It is entirely the rule author&rsquo;s responsibility to include tags in the
action&rsquo;s command. In particular, it is the code of the rule&rsquo;s action
that decides which, if any, tags are taken into account and if they come
from the rule dependencies, products or both. (Unfortunately, the built-in
rules themselves are sometimes a bit inconsistent on this.)</p>

<a name="Dynamic.dependencies..a.id..rules-dynamic-deps....a."></a>
<h3>Dynamic dependencies <a id="rules-dynamic-deps"></a></h3>

<p>In the action <code>ocamldep_ml_command</code> of the previous example, the
<code>_build</code> parameter (of type <code>PLUGIN.builder</code>) was ignored, because the
rule had no dynamic dependencies; no need to build extra targets
determined during the execution of the rule itself. The static
dependency is built by ocamlbuild&rsquo;s resolution engine before the
action executed.</p>

<p>The following example demonstrates dynamic depencies:</p>

<pre><code>let target_list env build =
    let itarget = env "%.itarget" in
    let targets =
      let dir = Pathname.dirname itarget in
      let files = string_list_of_file itarget in
      List.map (fun file -&gt; [Pathname.concat dir file]) files
    in
    let results = List.map Outcome.good (build targets) in
    let link_command result =
      Cmd (S [A "ln"; A "-sf";
              P (Pathname.concat !Options.build_dir result);
              A Pathname.pwd])
    in
    Seq (List.map link_command results)

rule "target files"
  ~dep:"%.itarget"
  ~stamp:"%.otarget"
  ~doc:"If foo.itarget contains a list of ocamlbuild targets, \
        asking ocamlbuild to produce foo.otarget will \
        build each of those targets in turn."
  target_list
</code></pre>

<p>The <code>string_list_of_file</code> function reads a file and returns the list of
its lines &ndash; it is used in the various builtin rules for files
containing other file or module paths
(e.g. <code>.mllib</code>, <code>.odocl</code> or here <code>.itarget</code>).</p>

<p>The function <code>build</code> takes as argument a list of lists, to be
understood as a conjunction of disjunctions. For example, if passed
the input <code>[["a/foo.byte"; "b/foo.byte"]; ["a/foo.native";
"b/foo.native"]]</code>, it tries to build ((<code>a/foo.byte</code> OR <code>b/foo.byte</code>)
AND (<code>a/foo.native</code> OR <code>b/foo.native</code>)). The disjunctive structure
(this OR that) is useful because we are often not quite sure where a
particular target may be (for example the module Foo may be in any of
the subdirectories in the include path). The conjunctive structure
(this AND that) is essential to parallelizing the build: ocamlbuild
tries to build all these targets in parallel, whereas sequential
invocation of the build function on each of the disjunctions would
give sequential builds.</p>

<p>The function <code>build</code> returns a list of outcomes (<code>(string, exn)
Outcome.t</code> &ndash; <code>Outcome.t</code> is just a disjoint-sum type), that is either
a <code>string</code> (the possible target that could be built) or an exception.
<code>Outcome.good</code> returns the good result if it exists, or raises the
exception.</p>

<a name="Stamps..a.id..rules-stamps....a."></a>
<h3>Stamps <a id="rules-stamps"></a></h3>

<p>In the rule above, the production <code>"%.otarget"</code> is not passed as
<code>~prod</code> parameter, but as a <code>~stamp</code>. Stamps are special files that
record the list of digests of the dynamic dependencies of the rule
that produced them.</p>

<p>This is useful to know whether a target should be re-compiled, or
whether it is already up-to-date from a previous build and can be just
kept as-is. Imagine that a rule to produce a file <code>foo.weird</code> depends
on the rules listed in the corresponding <code>foo.itarget</code> (and then
performs some build action); when should <code>foo.weird</code> be rebuilt, and
when is it up-to-date? More precisely, after we have built the targets
of <code>foo.itarget</code>, how do we know whether we should re-run the build
action of <code>foo.weird</code>? Obviously, just checking if the <code>foo.itarget</code>
file changed is not enough (the list of targets could be identical and
yet, if one of the target changed, <code>foo.weird</code> must be rebuilt).</p>

<p>This is where <code>foo.otarget</code> comes in: because it contains a list of
digests of the dependencies of <code>foo.itarget</code>, <code>foo.weird</code> can
statically depend on <code>foo.otarget</code> &ndash; and does not need to depend on
<code>foo.itarget</code> directly, and it will transitively depend on it through
<code>foo.otarget</code>. This stamp file will change each time one of the
<code>foo.itarget</code> elements changes, and thus <code>foo.weird</code> will be rebuilt
exactly as necessary.</p>

<p>Such stamps should be used each time a rule has no natural file output
to use as output (the case of <code>.itarget</code>), or when this file output
does not contain enough information for its digest to correctly
require rebuilding. The latter case occurs in the rule to build
ocamldoc documentation <code>%.docdir/index.html</code>: the <code>index.html</code> only
lists the documented modules, it does not contain their documentation
which is in other generated files. The rule thus produces a stamp
<code>%.docdir/html.stamp</code>, one which you should depend if you want your
rule to be re-executed each time the documentation changes.</p>

<a name="Pattern.variables..a.id..rules-patterns....id."></a>
<h3>Pattern variables <a id="rules-patterns"></id></h3>

<p>Most rules need exactly one pattern variable and use <code>%</code> for this
purpose. One can use any string of the form <code>%(identifier)</code> as pattern
variable, or even <code>%(identifier:pattern)</code>, in which case the pattern
will be only be matched by a string matching the corresponding
<code>pattern</code>. For example, the rule to produce the dynamic library
archive <code>dllfoo.so</code> from the file list <code>libfoo.clib</code> starts as follows:</p>

<pre><code>rule "ocaml C stubs: clib &amp; (o|obj)* -&gt; (a|lib) &amp; (so|dll)"
  ~prods:(["%(path:&lt;**/&gt;)lib%(libname:&lt;*&gt; and not &lt;*.*&gt;)"-.-ext_lib] @
          if Ocamlbuild_config.supports_shared_libraries then
            ["%(path:&lt;**/&gt;)dll%(libname:&lt;*&gt; and not &lt;*.*&gt;)"-.-ext_dll]
          else
            [])
  ~dep:"%(path)lib%(libname).clib"
</code></pre>

<a name="Complete.example:.menhir.support.in.OCamlbuild..a.id..plugins-example....a."></a>
<h2>Complete example: menhir support in OCamlbuild <a id="plugins-example"></a></h2>

<pre><code>rule "ocaml: modular menhir (mlypack)"
  ~prods:["%.mli" ; "%.ml"]
  ~deps:["%.mlypack"]
  ~doc:"Menhir supports building a parser by composing several .mly files \
        together, containing different parts of the grammar description. \
        To use that feature with ocamlbuild, you should create a .mlypack \
        file with the same syntax as .mllib or .mlpack files: \
        a whitespace-separated list of the capitalized module names \
        of the .mly files you want to combine together."
  (Ocaml_tools.menhir_modular "%" "%.mlypack" "%.mlypack.depends");

rule "ocaml: menhir modular dependencies"
  ~prod:"%.mlypack.depends"
  ~dep:"%.mlypack"
  (Ocaml_tools.menhir_modular_ocamldep_command "%.mlypack" "%.mlypack.depends");

rule "ocaml: menhir"
  ~prods:["%.ml"; "%.mli"]
  ~deps:["%.mly"; "%.mly.depends"]
  ~doc:"Invokes menhir to build the .ml and .mli files derived from a .mly \
        grammar. If you want to use ocamlyacc instead, you must disable the \
        -use-menhir option that was passed to ocamlbuild."
  (Ocaml_tools.menhir "%.mly");

rule "ocaml: menhir dependencies"
  ~prod:"%.mly.depends"
  ~dep:"%.mly"
  (Ocaml_tools.menhir_ocamldep_command "%.mly" "%.mly.depends");

flag ["ocaml"; "menhir"] (atomize !Options.ocaml_yaccflags);

flag [ "ocaml" ; "menhir" ; "explain" ] (S[A "--explain"]);
flag [ "ocaml" ; "menhir" ; "infer" ] (S[A "--infer"]);

List.iter begin fun mode -&gt;
  flag [ mode; "only_tokens" ] (S[A "--only-tokens"]);
  pflag [ mode ] "external_tokens" (fun name -&gt;
    S[A "--external-tokens"; A name]);
end [ "menhir"; "menhir_ocamldep" ];
</code></pre>

<p>where the menhir-specific actions in <code>Ocaml_tools</code> are defined as follows:</p>

<pre><code>let menhir_ocamldep_command' tags ~menhir_spec out =
  let menhir = if !Options.ocamlyacc = N then V"MENHIR" else !Options.ocamlyacc in
  Cmd(S[menhir; T tags; A"--raw-depend";
        A"--ocamldep"; Quote (ocamldep_command' Tags.empty);
        menhir_spec ; Sh "&gt;"; Px out])

let menhir_ocamldep_command arg out env _build =
  let arg = env arg and out = env out in
  let tags = tags_of_pathname arg++"ocaml"++"menhir_ocamldep" in
  menhir_ocamldep_command' tags ~menhir_spec:(P arg) out

let import_mlypack build mlypack =
  let tags1 = tags_of_pathname mlypack in
  let files = string_list_of_file mlypack in
  let include_dirs = Pathname.include_dirs_of (Pathname.dirname mlypack) in
  let files_alternatives =
    List.map begin fun module_name -&gt;
      expand_module include_dirs module_name ["mly"]
    end files
  in
  let files = List.map Outcome.good (build files_alternatives) in
  let tags2 =
    List.fold_right
      (fun file -&gt; Tags.union (tags_of_pathname file))
      files tags1
  in
  (tags2, files)

let menhir_modular_ocamldep_command mlypack out env build =
  let mlypack = env mlypack and out = env out in
  let (tags,files) = import_mlypack build mlypack in
  let tags = tags++"ocaml"++"menhir_ocamldep" in
  let menhir_base = Pathname.remove_extensions mlypack in
  let menhir_spec = S[A "--base" ; P menhir_base ; atomize_paths files] in
  menhir_ocamldep_command' tags ~menhir_spec out

let menhir_modular menhir_base mlypack mlypack_depends env build =
  let menhir = if !Options.ocamlyacc = N then "menhir" else !Options.ocamlyacc in
  let menhir_base = env menhir_base in
  let mlypack = env mlypack in
  let mlypack_depends = env mlypack_depends in
  let (tags,files) = import_mlypack build mlypack in
  let () = List.iter Outcome.ignore_good (build [[mlypack_depends]]) in
  Ocaml_compiler.prepare_compile build mlypack;
  let ocamlc_tags = tags++"ocaml"++"byte"++"compile" in
  let tags = tags++"ocaml"++"parser"++"menhir" in
  Cmd(S[menhir ;
        A "--ocamlc"; Quote(S[!Options.ocamlc; T ocamlc_tags; ocaml_include_flags mlypack]);
        T tags ; A "--base" ; Px menhir_base ; atomize_paths files])
</code></pre>

<!--
# Advanced Examples

## Complex multi-directory code organization

TODO

## Mixing C and OCaml code

TODO

## Using custom preprocessors

TODO
-->


<a name="Contributing.to.OCamlbuild..a.id..contributing....a."></a>
<h1>Contributing to OCamlbuild <a id="contributing"></a></h1>

<p>Any contribution is warmly welcome.</p>

<p>Bugs should be reported on the Mantis bugtracked of the OCaml
distribution, <a href="http://http://caml.inria.fr/mantis/">http://http://caml.inria.fr/mantis/</a>, using the
ocamlbuild-specific category.</p>

<p>Contributions under the form of patches are most welcome. OCamlbuild
is free software, licensed under the GNU LGPL, and we do our best to
review, give feedback, and integrate patches uploaded on Mantis or
pull requests on the github mirror of the OCaml distribution,
<a href="https://github.com/ocaml/ocaml/pulls">https://github.com/ocaml/ocaml/pulls</a>.</p>

<p>In particular, if you try to understand the implementation or
documentation, and understanding some part of it requires effort,
a patch containing implementation or documentation comments to clarify
it to future readers is an excellent idea.</p>

<p>Any ocamlbuild-related question can be asked on the caml-list
mailing-list: <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#99;&#x61;&#x6d;&#108;&#45;&#x6c;&#105;&#x73;&#116;&#64;&#x69;&#110;&#114;&#105;&#97;&#x2e;&#x66;&#114;">&#99;&#x61;&#x6d;&#108;&#45;&#108;&#105;&#115;&#116;&#x40;&#x69;&#110;&#114;&#105;&#x61;&#46;&#102;&#x72;</a>.</p>

</body>
</html>
